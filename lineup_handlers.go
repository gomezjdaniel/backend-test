package main

import (
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"github.com/apex/log"
	"github.com/labstack/echo/v4"
	"upper.io/db.v3"
)

func lineupID(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		str := c.Param("lineup_id")
		if str == "" {
			return next(c)
		}

		id, err := strconv.ParseInt(str, 10, 64)
		if err != nil {
			log.WithField("lineup_id", str).Debug("Failed to parse `lineup_id` as int64")
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid `lineup_id`")
		}

		c.Set("lineup_id", id)

		return next(c)
	}
}

func getLineupID(c echo.Context) (id int64) {
	id, _ = c.Get("lineup_id").(int64)
	return
}

const lineupsTable = "lineups"

var errLineupNotFound = errors.New("lineup not found")

func (s *server) createLineup(c echo.Context) error {
	req := new(lineup)
	if err := c.Bind(req); err != nil {
		log.WithError(err).Error("Invalid request")
		return c.NoContent(http.StatusBadRequest)
	}

	// Ensure LineupID is not set.
	if req.LineupID != 0 {
		log.WithError(fmt.Errorf("lineup_id was set")).Error("Invalid request")
		return c.NoContent(http.StatusUnprocessableEntity)
	}

	ret, err := s.db.Collection(lineupsTable).Insert(req)
	if err != nil {
		log.WithError(err).Error("Failed to insert lineup in the store")
		return c.NoContent(http.StatusInternalServerError)
	}

	id, err := toInt64(ret)
	if err != nil {
		log.WithError(err).Error("Failed to cast autogenerated ID after inserting a lineup")
		return c.NoContent(http.StatusInternalServerError)
	}

	return c.JSON(http.StatusOK, &lineup{
		LineupID: id,
	})
}

func (s *server) getLineup(c echo.Context) error {
	found := new(lineup)

	err := s.db.Collection(lineupsTable).Find("lineup_id", getLineupID(c)).One(found)
	if err == db.ErrNoMoreRows {
		log.WithField("lineup_id", getLineupID(c)).Debug("lineup not found")
		return echo.NewHTTPError(http.StatusNotFound, errLineupNotFound.Error())
	}
	if err != nil {
		log.WithError(err).Error("Failed to retrieve lineup from the store")
		return c.NoContent(http.StatusInternalServerError)
	}

	var players []player
	if c.QueryParam("with-players") == "true" {
		err := s.db.Select("p.*").From(fmt.Sprintf("%s AS p", playersTable)).
			Join(fmt.Sprintf("%s AS l", lineupPlayersTable)).
			On("p.player_id = l.player_id").And("lineup_id", getLineupID(c)).
			All(&players)
		if err != nil {
			log.WithError(err).Error("Failed to retrieve lineup with players from the store")
			return c.NoContent(http.StatusInternalServerError)
		}
	}

	return c.JSON(http.StatusOK, struct {
		*lineup
		Players []player `json:"players,omitempty"`
	}{
		lineup:  found,
		Players: players,
	})
}

func (s *server) updateLineup(c echo.Context) error {
	req := new(lineup)
	if err := c.Bind(req); err != nil {
		return err
	}

	// Ensure LineupID is not set.
	if req.LineupID != 0 {
		log.WithError(fmt.Errorf("lineup_id was set")).Error("Invalid request")
		return c.NoContent(http.StatusBadRequest)
	}

	err := s.db.Collection(lineupsTable).Find("lineup_id", getLineupID(c)).Update(req)
	if err != nil {
		log.WithError(err).Error("Failed to update lineup from the store")
		return c.NoContent(http.StatusInternalServerError)
	}

	return c.NoContent(http.StatusOK)
}

func (s *server) deleteLineup(c echo.Context) error {
	err := s.db.Collection(lineupsTable).Find("lineup_id", getLineupID(c)).Delete()
	if err != nil {
		log.WithError(err).Error("Failed to delete lineup from the store")
		return c.NoContent(http.StatusInternalServerError)
	}

	return c.NoContent(http.StatusOK)
}

const lineupPlayersTable = "lineup_players"

func (s *server) addPlayerToLineup(c echo.Context) error {
	req := new(player)
	if err := c.Bind(req); err != nil {
		return err
	}

	if getLineupID(c) == 0 {
		return c.NoContent(http.StatusUnprocessableEntity)
	}

	if req.PlayerID == int64(0) {
		return c.NoContent(http.StatusUnprocessableEntity)
	}

	// TODO: enclose this part in a transaction.
	count, err := s.db.Collection(lineupPlayersTable).Find("lineup_id", getLineupID(c)).Count()
	if err != nil {
		log.WithError(err).Error("Failed to count players from lineup")
		return c.NoContent(http.StatusInternalServerError)
	}

	// Check if lineup has already 11 players.
	if count == uint64(11) {
		log.WithField("lineup_id", getLineupID(c)).Debug("Lineup has reached maximum players")
		return echo.NewHTTPError(http.StatusForbidden, "lineup has reached maximum players")
	}

	_, err = s.db.Collection(lineupPlayersTable).Insert(&struct {
		PlayerID int64 `db:"player_id"`
		LineupID int64 `db:"lineup_id"`
	}{
		LineupID: getLineupID(c),
		PlayerID: req.PlayerID,
	})
	if err != nil {
		log.WithError(err).Error("Failed to insert player in the lineup")
		return c.NoContent(http.StatusInternalServerError)
	}

	return c.NoContent(http.StatusOK)
}

func (s *server) deletePlayerFromLineup(c echo.Context) error {
	req := new(player)
	if err := c.Bind(req); err != nil {
		return err
	}

	err := s.db.Collection(lineupPlayersTable).Find("lineup_id", getLineupID(c)).
		And("player_id", req.PlayerID).Delete()
	if err != nil {
		log.WithError(err).Error("Failed to delete player from lineup")
		return c.NoContent(http.StatusInternalServerError)
	}

	return c.NoContent(http.StatusOK)
}
